const char *fallbackShader_dlight_vp =
"attribute vec3 attr_Position;\n"
"attribute vec4 attr_TexCoord0;\n"
"attribute vec3 attr_Normal;\n"
"\n"
"uniform vec4   u_DlightInfo;\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"uniform int    u_DeformGen;\n"
"uniform float  u_DeformParams[5];\n"
"uniform float  u_Time;\n"
"#endif\n"
"\n"
"uniform vec4   u_Color;\n"
"uniform mat4   u_ModelViewProjectionMatrix;\n"
"\n"
"varying vec2   var_Tex1;\n"
"varying vec4   var_Color;\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"vec3 DeformPosition(const vec3 pos, const vec3 normal, const vec2 st)\n"
"{\n"
"	if (u_DeformGen == 0)\n"
"	{\n"
"		return pos;\n"
"	}\n"
"\n"
"	float base =      u_DeformParams[0];\n"
"	float amplitude = u_DeformParams[1];\n"
"	float phase =     u_DeformParams[2];\n"
"	float frequency = u_DeformParams[3];\n"
"	float spread =    u_DeformParams[4];\n"
"\n"
"	if (u_DeformGen == DGEN_BULGE)\n"
"	{\n"
"		phase *= st.x;\n"
"	}\n"
"	else // if (u_DeformGen <= DGEN_WAVE_INVERSE_SAWTOOTH)\n"
"	{\n"
"		phase += dot(pos.xyz, vec3(spread));\n"
"	}\n"
"\n"
"	float value = phase + (u_Time * frequency);\n"
"	float func;\n"
"\n"
"	if (u_DeformGen == DGEN_WAVE_SIN)\n"
"	{\n"
"		func = sin(value * 2.0 * M_PI);\n"
"	}\n"
"	else if (u_DeformGen == DGEN_WAVE_SQUARE)\n"
"	{\n"
"		func = sign(0.5 - fract(value));\n"
"	}\n"
"	else if (u_DeformGen == DGEN_WAVE_TRIANGLE)\n"
"	{\n"
"		func = abs(fract(value + 0.75) - 0.5) * 4.0 - 1.0;\n"
"	}\n"
"	else if (u_DeformGen == DGEN_WAVE_SAWTOOTH)\n"
"	{\n"
"		func = fract(value);\n"
"	}\n"
"	else if (u_DeformGen == DGEN_WAVE_INVERSE_SAWTOOTH)\n"
"	{\n"
"		func = (1.0 - fract(value));\n"
"	}\n"
"	else // if (u_DeformGen == DGEN_BULGE)\n"
"	{\n"
"		func = sin(value);\n"
"	}\n"
"\n"
"	return pos + normal * (base + func * amplitude);\n"
"}\n"
"#endif\n"
"\n"
"void main()\n"
"{\n"
"	vec3 position = attr_Position;\n"
"	vec3 normal = attr_Normal;\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"	position = DeformPosition(position, normal, attr_TexCoord0.st);\n"
"#endif\n"
"\n"
"	gl_Position = u_ModelViewProjectionMatrix * vec4(position, 1.0);\n"
"\n"
"	vec3 dist = u_DlightInfo.xyz - position;\n"
"\n"
"	var_Tex1 = dist.xy * u_DlightInfo.a + vec2(0.5);\n"
"	float dlightmod = step(0.0, dot(dist, normal));\n"
"	dlightmod *= clamp(2.0 * (1.0 - abs(dist.z) * u_DlightInfo.a), 0.0, 1.0);\n"
"\n"
"	var_Color = u_Color * dlightmod;\n"
"}\n"
;
